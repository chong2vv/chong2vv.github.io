<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>iOS整理（摘抄与总结面试题为主） | 七月小筑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="文章内题目主要来源于标哥的博客以及招聘一个靠谱的iOS上摘抄及整理，其中有些回答略加修改和举例，并不保证百分百正确，有问题的地方还希望大家可以不吝赐教，谢谢~本文为www.chong2vv.com原创出品，欢迎转载，转载时请注明出处！1.什么情况使用weak关键字，相比assign有什么不同？使用weak关键字的主要场景:

在ARC下，在有可能出现循环应用的时候往往要通过让其中的一端使用weak">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS整理（摘抄与总结面试题为主）">
<meta property="og:url" content="http://www.chong2vv.com/2016/05/20/东的面试整理/index.html">
<meta property="og:site_name" content="七月小筑">
<meta property="og:description" content="文章内题目主要来源于标哥的博客以及招聘一个靠谱的iOS上摘抄及整理，其中有些回答略加修改和举例，并不保证百分百正确，有问题的地方还希望大家可以不吝赐教，谢谢~本文为www.chong2vv.com原创出品，欢迎转载，转载时请注明出处！1.什么情况使用weak关键字，相比assign有什么不同？使用weak关键字的主要场景:

在ARC下，在有可能出现循环应用的时候往往要通过让其中的一端使用weak">
<meta property="og:updated_time" content="2016-05-24T13:32:35.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS整理（摘抄与总结面试题为主）">
<meta name="twitter:description" content="文章内题目主要来源于标哥的博客以及招聘一个靠谱的iOS上摘抄及整理，其中有些回答略加修改和举例，并不保证百分百正确，有问题的地方还希望大家可以不吝赐教，谢谢~本文为www.chong2vv.com原创出品，欢迎转载，转载时请注明出处！1.什么情况使用weak关键字，相比assign有什么不同？使用weak关键字的主要场景:

在ARC下，在有可能出现循环应用的时候往往要通过让其中的一端使用weak">
  
    <link rel="alternative" href="/atom.xml" title="七月小筑" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/dong.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">七月</a></h1>
		</hgroup>

		
		<p class="header-subtitle">心中无码</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/SQL必知必会笔记">SQL必知必会笔记</a></li>
				        
							<li><a href="/tags/基础整理">iOS学习</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/SQLite/" style="font-size: 20px;">SQLite</a> <a href="/tags/SQL必知必会笔记/" style="font-size: 20px;">SQL必知必会笔记</a> <a href="/tags/Swift学习/" style="font-size: 10px;">Swift学习</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/基础整理/" style="font-size: 10px;">基础整理</a> <a href="/tags/小技巧/" style="font-size: 13.33px;">小技巧</a> <a href="/tags/数据库/" style="font-size: 20px;">数据库</a> <a href="/tags/随笔/" style="font-size: 16.67px;">随笔</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">爱情的巨轮说沉就沉，程序猿的独木舟屹立不倒</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">七月</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/dong.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">七月</h1>
			</hgroup>
			
			<p class="header-subtitle">心中无码</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/SQL必知必会笔记">SQL必知必会笔记</a></li>
		        
					<li><a href="/tags/基础整理">iOS学习</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-东的面试整理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/20/东的面试整理/" class="article-date">
  	<time datetime="2016-05-20T09:18:06.000Z" itemprop="datePublished">2016-05-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS整理（摘抄与总结面试题为主）
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/基础整理/">基础整理</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="文章内题目主要来源于标哥的博客以及招聘一个靠谱的iOS上摘抄及整理，其中有些回答略加修改和举例，并不保证百分百正确，有问题的地方还希望大家可以不吝赐教，谢谢-本文为www-chong2vv-com原创出品，欢迎转载，转载时请注明出处！"><a href="#文章内题目主要来源于标哥的博客以及招聘一个靠谱的iOS上摘抄及整理，其中有些回答略加修改和举例，并不保证百分百正确，有问题的地方还希望大家可以不吝赐教，谢谢-本文为www-chong2vv-com原创出品，欢迎转载，转载时请注明出处！" class="headerlink" title="文章内题目主要来源于标哥的博客以及招聘一个靠谱的iOS上摘抄及整理，其中有些回答略加修改和举例，并不保证百分百正确，有问题的地方还希望大家可以不吝赐教，谢谢~本文为www.chong2vv.com原创出品，欢迎转载，转载时请注明出处！"></a>文章内题目主要来源于<a href="http://www.henishuo.com/" target="_blank" rel="external">标哥</a>的博客以及<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#2-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8-weak-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9B%B8%E6%AF%94-assign-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C" target="_blank" rel="external">招聘一个靠谱的iOS</a>上摘抄及整理，其中有些回答略加修改和举例，并不保证百分百正确，有问题的地方还希望大家可以不吝赐教，谢谢~本文为<a href="http://www.chong2vv.com">www.chong2vv.com</a>原创出品，欢迎转载，转载时请注明出处！</h4><h3 id="1-什么情况使用weak关键字，相比assign有什么不同？"><a href="#1-什么情况使用weak关键字，相比assign有什么不同？" class="headerlink" title="1.什么情况使用weak关键字，相比assign有什么不同？"></a>1.什么情况使用weak关键字，相比assign有什么不同？</h3><p><strong>使用weak关键字的主要场景:</strong></p>
<ul>
<li>在ARC下，在有可能出现循环应用的时候往往要通过让其中的一端使用weak来解决，比如：delegate代理属性，通常就会声明为weak。</li>
<li>自身已经对他进行了一次强引用，没有必要再强引用时也会使用weak。比如：自定义IBOutlet控件属性一般也是用weak，当然也可以使用strong。<a id="more"></a>
</li>
</ul>
<p><strong>相比assign不同之处:</strong></p>
<ul>
<li><code>weak</code>关键字只能用于<code>对象</code>，对于<code>基本类型不能使用</code></li>
<li>assign既可以用于<code>对象</code>，也可以用于<code>基本类型</code>，但是只是简单地进行赋值操作而已</li>
</ul>
<h3 id="2-怎么用copy关键字？"><a href="#2-怎么用copy关键字？" class="headerlink" title="2.怎么用copy关键字？"></a>2.怎么用copy关键字？</h3><p><strong>copy的含义：</strong><br>copy关键字只能应用于<code>对象</code>，不能用于<code>基本类型</code>。copy属性会复制一份，并且强引用之，但是对于集合类型，通常并不能达到<code>深拷贝</code>的目的。NSString、NSArray、NSDictionary等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，当然很多时候都使用了strong来声明。<code>block</code>也使用copy关键字来声明。同时，若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</p>
<p><strong>参考答案：</strong></p>
<ul>
<li>copy适用于对象，无法应用于基本类型</li>
<li>在声明NSString类型时应始终使用<code>copy</code>,虽然也可以使用strong来声明，但是不推荐。因为在大多数情况下我们不希望字符串的值跟随着变化，所以比较推荐使用copy。当然，如果希望字符串的值跟随着赋值的字符串的值变化，那么我们可以使用strong、retain。</li>
<li>对于不可变集合类型，虽然在防止外部的修改影响所传过来的值应该使用copy，但是大多数情况下使用strong也没有问题（我一般都是用strong来声明的。。。）但是反过来说，对于<code>可变</code>的集合类型，应该使用<code>strong</code>而不是用copy，因为copy会生成一个不可变的类型。</li>
<li>对于<code>block</code>要使用copy来声明</li>
</ul>
<p><em>附录：</em>使用NSCopying协议步骤：</p>
<ol>
<li>需声明该类遵从 NSCopying 协议</li>
<li>实现 NSCopying 协议。该协议只有一个方法: </li>
</ol>
<pre><code>    - (id)copyWithZone:(NSZone *)zone;


（注：具体请查看[招聘一个靠谱的iOS](https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88/%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88%EF%BC%88%E4%B8%8A%EF%BC%89.md#2-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%BD%BF%E7%94%A8-weak-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9B%B8%E6%AF%94-assign-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C)第五题，写的很赞很详细）
</code></pre><h3 id="3-在声明一个NSMutableArray的属性时，如果不声明nonatomic有什么影响？"><a href="#3-在声明一个NSMutableArray的属性时，如果不声明nonatomic有什么影响？" class="headerlink" title="3.在声明一个NSMutableArray的属性时，如果不声明nonatomic有什么影响？"></a>3.在声明一个NSMutableArray的属性时，如果不声明nonatomic有什么影响？</h3><p><strong>参考答案：</strong></p>
<p>当没有声明nonatomic时，系统会默认声明<code>atomic</code>原子操作，而这个属性使用了同步锁，这会大大的增加性能开销，影响应用性能。一般情况下并不要求属性必须是“原子的”，因为这并不能保证线程安全，所以要实现“线程安全”的操作，还需要采用更为深层的锁定机制，比如<em>NSSpinLock</em>、<em>@syncronized</em>等。</p>
<h3 id="4-对于一个可变数组的声明，如果是copy的话有什么影响？"><a href="#4-对于一个可变数组的声明，如果是copy的话有什么影响？" class="headerlink" title="4.对于一个可变数组的声明，如果是copy的话有什么影响？"></a>4.对于一个可变数组的声明，如果是copy的话有什么影响？</h3><p><strong>参考答案：</strong><br>因为使用的是copy，因此实际得到是数组并不是NSMutableArray，而是NSArray类型的，也就是说该数组是<code>不可变类型</code>的。所以如果我们在使用时对改数组进行增删改的时候就会导致crash，如果单纯是查询的话则没有问题。同样，如果是单纯的查询，那么应该声明NSArray类型是最合适的。</p>
<h3 id="5-property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"><a href="#5-property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？" class="headerlink" title="5.@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？"></a>5.@property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的？</h3><p><strong>参考答案：</strong></p>
<h5 id="property的本质："><a href="#property的本质：" class="headerlink" title="@property的本质："></a>@property的本质：</h5><ol>
<li><p>@property = ivar（实例变量） + getter（取方法） + setter（存方法）</p>
</li>
<li><p>“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）</p>
</li>
</ol>
<h5 id="ivar、getter、setter如何生成并添加到类中："><a href="#ivar、getter、setter如何生成并添加到类中：" class="headerlink" title="ivar、getter、setter如何生成并添加到类中："></a>ivar、getter、setter如何生成并添加到类中：</h5><p>这是编译器自动合成的，通过@synthesize关键字指定，若不指定，默认为@synthesize propertyName = _propertyName;若手动实现了getter/setter方法，则不会自动合成。</p>
<p>现在编译器已经默认为我们添加@synthesize propertyName = _propertyName;因此不再需要手动添加了，除非你真的要改成员变量名。</p>
<p>生成getter方法时，会判断当前属性名是否有_，*比如声明属性为@property (nonatomic, copy) NSString *_name;那么所生成的成员变量名就会变成““_””_name，如果我们要手动生成getter方法，就要判断是否以_开头了。</p>
<p>不过，命名都要有规范，是不允许声明属性是使用_开头的，不规范的命名，在使用runtime时，会带来很多的不方便的。</p>
<h3 id="6-protocol和category中如何使用-property"><a href="#6-protocol和category中如何使用-property" class="headerlink" title="6.@protocol和category中如何使用 @property"></a>6.@protocol和category中如何使用 @property</h3><p><strong>参考答案：</strong></p>
<ul>
<li>在protocol中使用@property只会生成setter和getter方法声明，我们使用属性的目的是希望遵守我协议的对象能实现该属性</li>
<li><p>category使用@property也是只会生成setter和getter方法的声明，如果我们真的需要给category增加属性的实现，需要借助于运行时的两个函数：</p>
<ul>
<li>objc_setAssociatedObject</li>
<li>objc_getAssociatedObject</li>
</ul>
</li>
</ul>
<h3 id="7-runtime如何实现weak属性？"><a href="#7-runtime如何实现weak属性？" class="headerlink" title="7.runtime如何实现weak属性？"></a>7.runtime如何实现weak属性？</h3><p><strong>参考答案：</strong></p>
<ul>
<li>通过关联属性来实现</li>
<li>通过objc_storeWeak函数来实现（不过这种方式几乎没有遇到有人这么使用过）</li>
</ul>
<h3 id="8-property中有哪些属性关键字，后面可以有哪些修饰符？"><a href="#8-property中有哪些属性关键字，后面可以有哪些修饰符？" class="headerlink" title="8.@property中有哪些属性关键字，后面可以有哪些修饰符？"></a>8.@property中有哪些属性关键字，后面可以有哪些修饰符？</h3><p><strong>参考答案：</strong></p>
<ul>
<li>原子性：<code>nonatomic</code>（非原子操作）与<code>atomic</code>（原子操作）前者不使用同步锁后者使用同步锁，因此在性能的消耗上后者大于前者，在大多数情况下我们应该使用<code>nonatomic</code></li>
<li>读写权限：<code>readwrite</code>(读写)与<code>readonly</code> (只读)</li>
<li>内存管理相关：assign、retain、week、strong、copy（注意在ARC与MRC下的使用）</li>
<li><p>方法名：getter=、setter=set。</p>
<p>  <code>setter=\&lt;name\&gt;</code>一般用在特殊的情境下，比如:</p>
<p>  在数据反序列化、转模型的过程中，服务器返回的字段如果以 <code>init</code> 开头，所以你需要定义一个 <code>init</code> 开头的属性，但默认生成的 <code>setter</code> 与 <code>getter</code> 方法也会以 <code>init</code> 开头，而编译器会把所有以 <code>init</code> 开头的方法当成初始化方法，而初始化方法只能返回 self 类型，因此编译器会报错。</p>
</li>
</ul>
<ul>
<li>不常用的：nonnull、null_resettable、nullable（这个我从来没用过。。。）</li>
</ul>
<h3 id="9-属性声明为weak时，在结束时需要置空么？"><a href="#9-属性声明为weak时，在结束时需要置空么？" class="headerlink" title="9.属性声明为weak时，在结束时需要置空么？"></a>9.属性声明为weak时，在结束时需要置空么？</h3><p><strong>参考答案：</strong></p>
<p>不需要。在ARC下编译器会自动处理，因此不需要我们手动操作。</p>
<p>同时，在ARC的环境下dealloc通常是不需要实现的，写了反而会出错。（特殊情况下除外，比如需要释放某些资源时。例如UIWebView的delegate的置空、移除观察者等）</p>
<p>引申：runtime如何实现weak变量的自动置nil？</p>
<ul>
<li>untime对注册的类会进行布局，对于weak对象会放入一个hash表中。 用weak指向的对象内存地址作为key，当此对象的引用计数为0的时候会dealloc。假如weak指向的对象内存地址是a，那么就会以a为键，在这个 weak 表中搜索，找到所有以a为键的weak对象，从而设置为nil。</li>
<li>weak修饰的指针默认值是nil（在Objective-C中向nil发送消息是安全的）</li>
</ul>
<h3 id="10-ARC下不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#10-ARC下不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="10.ARC下不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>10.ARC下不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><p><strong>参考答案：</strong></p>
<ul>
<li>对于基本数据类型默认关键字是：atomic,readwrite,assign</li>
<li>对于普通的Objective-C对象：atomic,readwrite,strong</li>
</ul>
<h3 id="11-objc中向一个nil对象发送消息将会发生什么？"><a href="#11-objc中向一个nil对象发送消息将会发生什么？" class="headerlink" title="11.objc中向一个nil对象发送消息将会发生什么？"></a>11.objc中向一个nil对象发送消息将会发生什么？</h3><p><strong>参考答案：</strong></p>
<p>在Objective-C中向nil发送消息是完全有效的，只是在运行时不会有任何作用，因为在运行时调用时，objc_msgSend函数传过去的receiver是nil，而内部会判断receiver是否为nil，若为nil则什么也不干。同样，若cmd也就是selector为nil，也是什么也不干。</p>
<h3 id="12-什么时候会报unrecognized-selector的异常？"><a href="#12-什么时候会报unrecognized-selector的异常？" class="headerlink" title="12.什么时候会报unrecognized selector的异常？"></a>12.什么时候会报unrecognized selector的异常？</h3><p><strong>参考答案：</strong>(直接摘抄标哥的原文了)</p>
<p>下面只讲述对象方法的解析过程：</p>
<ul>
<li>第一步：+ (BOOL)resolveInstanceMethod:(SEL)sel实现方法，指定是否动态添加方法。若返回NO，则进入下一步，若返回YES，则通过class_addMethod函数动态地添加方法，消息得到处理，此流程完毕。</li>
<li>第二步：在第一步返回的是NO时，就会进入-(id)forwardingTargetForSelector:(SEL)aSelector方法，这是运行时给我们的第二次机会，用于指定哪个对象响应这个selector。不能指定为self。若返回nil，表示没有响应者，则会进入第三步。若返回某个对象，则会调用该对象的方法。</li>
<li>第三步：若第二步返回的是nil，则我们首先要通过- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector指定方法签名，若返回nil，则表示不处理。若返回方法签名，则会进入下一步。</li>
<li>第四步：当第三步返回方法方法签名后，就会调用- (void)forwardInvocation:(NSInvocation *)anInvocation方法，我们可以通过anInvocation对象做很多处理，比如修改实现方法，修改响应对象等</li>
<li>第五步：若没有实现- (void)forwardInvocation:(NSInvocation *)anInvocation方法，那么会进入- (void)doesNotRecognizeSelector:(SEL)aSelector方法。若我们没有实现这个方法，那么就会crash，然后提示打不到响应的方法。到此，动态解析的流程就结束了。</li>
</ul>
<h3 id="13-objc中的类方法和实例方法有什么本质区别和联系？"><a href="#13-objc中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="13.objc中的类方法和实例方法有什么本质区别和联系？"></a>13.objc中的类方法和实例方法有什么本质区别和联系？</h3><p><strong>参考答案：</strong></p>
<h5 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h5><ul>
<li>类方法是属于类对象的</li>
<li><p>类方法只能通过类对象调用，不能使用实例对象直接操作    </p>
<p>例如： 定义一个Person类，同时声明一个类方法</p>
</li>
</ul>
<pre><code>+(void)doWork
</code></pre><p>  定义一个Person的实例对象 </p>
<pre><code>Person *person = [[Person alloc] init]
</code></pre><p>  那么在调用doWork方法上应该使用</p>
<pre><code>[Person doWork]
</code></pre><p>  而非    </p>
<pre><code>[person doWork]
</code></pre><ul>
<li>类方法中的self是类对象</li>
<li>类方法可以调用其他的类方法</li>
<li><p>类方法中不能访问成员变量</p>
<p>例如：在Person 定义一个变量为name。</p>
<p>那么在类方法中无法访问name这个变量</p>
</li>
</ul>
<pre><code>name = @&quot;逗逗&quot;;
</code></pre><ul>
<li>类方法中不定直接调用对象</li>
</ul>
<p>  类同上，定义一个:</p>
<pre><code>-(void) comeOn
</code></pre><p>  在类方法中无法使用:</p>
<pre><code>[self comeOn];
</code></pre><h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><ul>
<li>实例方法是属于实例对象的</li>
<li>实例方法只能通过实例对象调用</li>
<li>实例方法中的self是实例对象</li>
<li>实例方法中可以访问成员变量</li>
<li>实例方法中直接调用实例方法</li>
<li>实例方法中也可以调用类方法(通过类名)</li>
</ul>
<h3 id="14-runloop和线程有什么关系？"><a href="#14-runloop和线程有什么关系？" class="headerlink" title="14.runloop和线程有什么关系？"></a>14.runloop和线程有什么关系？</h3><p><strong>参考答案：</strong></p>
<p>正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loop是线程的基础架构部分， Cocoa 和 CoreFundation都提供了方便配置和管理线程的 run loop （以下都以 Cocoa 为例）。每个线程，包括程序的主线程都有与之相应的run loop。</p>
<ul>
<li>主线程的run loop默认是启动的</li>
<li>对非主线程来说，run loop默认是没有启动的。如果你需要更多的线程交互则可以手动配置和启动，如果线程只是去执行一个长时间的已确定的任务则不需要。</li>
</ul>
<p>在任何一个Cocoa程序的线程中，可以通过：</p>
<pre><code>NSRunLoop *runloop = [NSRunLoop currentRunLoop];
</code></pre><p>来获取当前线程的runloop</p>
<h3 id="15-在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"><a href="#15-在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？" class="headerlink" title="15.在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？"></a>15.在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？</h3><p><strong>参考答案：</strong></p>
<p>RunLoop只能同时运行在一种mode下。因此，如果要换mode，那么当前的loop也需要暂停，并重启成新的mode。利用这个机制，ScrollView滚动过程中NSDefaultRunLoopMode（kCFRunLoopDefaultMode）的mode会切换到UITrackingRunLoopMode来保证ScrollView的流畅滑动，只能在NSDefaultRunLoopMode模式下处理的事件会影响scrllView的滑动。</p>
<p>原因：如果我们把一个NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环中的时候, ScrollView滚动过程中会因为mode的切换，而导致NSTimer将不再被调度。</p>
<p>同时因为mode还是可定制的，所以Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes（kCFRunLoopCommonModes）来解决。代码如下：</p>
<pre><code>[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES];
NSTimer *timer = [NSTimer timerWithTimeInterval:1.0 target:self selector:@selector(timerTick:) userInfo:nil repeats:YES];
[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];
</code></pre><h3 id="16-objc使用什么机制管理对象内存？"><a href="#16-objc使用什么机制管理对象内存？" class="headerlink" title="16.objc使用什么机制管理对象内存？"></a>16.objc使用什么机制管理对象内存？</h3><p><strong>参考答案：</strong>（关于内存方面推荐一本书：Objective-C高级编程 iOS与OS X多线程和内存管理 ,其中针对内存管理、block、多线程的讲解都是很不错的）</p>
<p>通过引用计数器(retainCount)的机制来决定对象是否需要释放。 每次runloop完成一个循环的时候，都会检查对象的 retainCount，如果retainCount为0，说明该对象没有地方需要继续使用了，可以释放掉了。</p>
<h3 id="17-ARC通过什么方式帮助开发者管理内存？"><a href="#17-ARC通过什么方式帮助开发者管理内存？" class="headerlink" title="17.ARC通过什么方式帮助开发者管理内存？"></a>17.ARC通过什么方式帮助开发者管理内存？</h3><p><strong>参考答案：</strong></p>
<p>ARC相对于MRC，不是在编译时添加retain/release/autorelease这么简单。应该是编译期和运行期两部分共同帮助开发者管理内存。</p>
<ul>
<li>在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）</li>
<li>ARC也包含运行期组件，这个地方做的优化比较复杂，但也不能被忽略，手动去做未必优化得好，因此直接交给编译器来优化，相信苹果吧！</li>
</ul>
<h3 id="18-BAD-ACCESS在什么情况下出现？如何调试BAD-ACCESS错误？"><a href="#18-BAD-ACCESS在什么情况下出现？如何调试BAD-ACCESS错误？" class="headerlink" title="18.BAD_ACCESS在什么情况下出现？如何调试BAD_ACCESS错误？"></a>18.BAD_ACCESS在什么情况下出现？如何调试BAD_ACCESS错误？</h3><p><strong>参考答案：</strong></p>
<h5 id="出现："><a href="#出现：" class="headerlink" title="出现："></a>出现：</h5><p>这种问题是经常遇到的，在开发时经常会出现BAD_ACCESS。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。</p>
<h5 id="调试："><a href="#调试：" class="headerlink" title="调试："></a>调试：</h5><ol>
<li>重写对象的respondsToSelector方法，先找到出现EXECBADACCESS前访问的最后一个object</li>
<li>设置Enable Zombie Objects</li>
<li>设置全局断点快速定位问题代码所在行，接收所有的异常</li>
<li>Xcode7已经集成了BAD_ACCESS捕获功能：Address Sanitizer，与步骤2一样设置</li>
</ol>
<h3 id="19-苹果是如何实现autoreleasepool的？"><a href="#19-苹果是如何实现autoreleasepool的？" class="headerlink" title="19.苹果是如何实现autoreleasepool的？"></a>19.苹果是如何实现autoreleasepool的？</h3><p><strong>参考答案：</strong></p>
<p>autoreleasepool以一个队列数组的形式实现,主要通过下列三个函数完成.</p>
<ul>
<li>objc_autoreleasepoolPush</li>
<li>objc_autoreleasepoolPop</li>
<li>objc_autorelease</li>
</ul>
<p>看函数名就可以知道，对autorelease分别执行push、pop操作。销毁对象时执行release操作。</p>
<h3 id="20-使用block时什么情况会发生引用循环，如何解决？"><a href="#20-使用block时什么情况会发生引用循环，如何解决？" class="headerlink" title="20.使用block时什么情况会发生引用循环，如何解决？"></a>20.使用block时什么情况会发生引用循环，如何解决？</h3><p><strong>参考答案：</strong></p>
<p>一个对象中强引用了block，在block中又使用了该对象，就会发生循环引用。 解决方法是将该对象使用_weak或者_block修饰符修饰之后再在block中使用。</p>
<pre><code>__weak __typeof(_name) weakName = _name;
self.vc = [[HYBController alloc] init];
vc.successBlock = ^(NSString *name) {
  weakName = name;
 // 如果直接使用_name，则会造成循环引用
  // _name = name;
};
</code></pre><h3 id="21-在block内如何修改block外部变量？"><a href="#21-在block内如何修改block外部变量？" class="headerlink" title="21.在block内如何修改block外部变量？"></a>21.在block内如何修改block外部变量？</h3><p><strong>参考答案：</strong></p>
<p>默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上__block来让其写操作生效，示例代码如下:</p>
<pre><code>__block int a = 0;
void  (^foo)(void) = ^{ 
 a = 1; 
}

foo(); 
</code></pre><h3 id="22-GCD的队列（dispatch-queue-t）有哪此类型？"><a href="#22-GCD的队列（dispatch-queue-t）有哪此类型？" class="headerlink" title="22.GCD的队列（dispatch_queue_t）有哪此类型？"></a>22.GCD的队列（dispatch_queue_t）有哪此类型？</h3><p><strong>参考答案：</strong></p>
<p>只有两种类型：</p>
<ul>
<li>串行队列Serial Dispatch Queue</li>
<li>并行队列Concurrent Dispatch Queue</li>
</ul>
<h3 id="23-如何用GCD同步若干个异步调用？"><a href="#23-如何用GCD同步若干个异步调用？" class="headerlink" title="23.如何用GCD同步若干个异步调用？"></a>23.如何用GCD同步若干个异步调用？</h3><p><strong>参考答案：</strong></p>
<p>举例：根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图<br>使用Dispatch Group追加block到Global Group Queue,这些block如果全部执行完毕，就会执行Main Dispatch Queue中的结束处理的block。<br>当放到group中的所有请求都完成时，才会回调dispatch_group_notify的block：</p>
<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
dispatch_group_async(group, queue, ^{ /*加载图片1 */ });
dispatch_group_async(group, queue, ^{ /*加载图片2 */ });
dispatch_group_async(group, queue, ^{ /*加载图片3 */ }); 
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
        // 合并图片
});
</code></pre><h3 id="24-dispatch-barrier-async的作用是什么？"><a href="#24-dispatch-barrier-async的作用是什么？" class="headerlink" title="24.dispatch_barrier_async的作用是什么？"></a>24.dispatch_barrier_async的作用是什么？</h3><p><strong>参考答案：</strong></p>
<p>在并行队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续进行，使用 barrier 来等待之前任务完成，避免数据竞争等问题。</p>
<p>barrier是屏障的意思，就是说在处理竞争资源时，使用dispatch_barrier_async函数会等待追加到Concurrent Dispatch Queue并行队列中的操作全部执行完之后，然后再执行 dispatch_barrier_async 函数追加的处理，等dispatch_barrier_async追加的处理执行结束之后，Concurrent Dispatch Queue才恢复之前的动作继续执行。</p>
<p>打个比方：比如你们公司周末跟团旅游，高速休息站上，司机说：大家都去上厕所，速战速决，上完厕所就上高速。超大的公共厕所，大家同时去，程序猿很快就结束了，但程序媛就可能会慢一些，即使你第一个回来，司机也不会出发，司机要等待所有人都回来后，才能出发。 dispatch_barrier_async 函数追加的内容就如同 “上完厕所就上高速”这个动作。</p>
<p>注意：使用 dispatch_barrier_async ，该函数只能搭配自定义并行队列 dispatch_queue_t 使用。不能使用： dispatch_get_global_queue ，否则 dispatch_barrier_async 的作用会和 dispatch_async 的作用一模一样。</p>
<h3 id="25-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"><a href="#25-用-property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？" class="headerlink" title="25.用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？"></a>25.用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？</h3><p><strong>参考答案：</strong></p>
<ol>
<li>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.</li>
<li><p>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.</p>
<p> copy 此特质所表达的所属关系与 strong 类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为 NSString 时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个 NSMutableString 类的实例。这个类是 NSString 的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。</p>
</li>
</ol>
<p><em>举例说明：</em></p>
<p>定义一个以 strong 修饰的 array：</p>
<pre><code>@property (nonatomic ,readwrite, strong) NSArray *array;
</code></pre><p>然后进行下面的操作：</p>
<pre><code>NSMutableArray *mutableArray = [[NSMutableArray alloc] init];
NSArray *array = @[ @1, @2, @3, @4 ];
self.array = mutableArray;
[mutableArray removeAllObjects];;
NSLog(@&quot;%@&quot;,self.array);

[mutableArray addObjectsFromArray:array];
self.array = [mutableArray copy];
[mutableArray removeAllObjects];;
NSLog(@&quot;%@&quot;,self.array);
</code></pre><p>打印结果如下所示：</p>
<pre><code>2015-09-27 19:10:32.523 CYLArrayCopyDmo[10681:713670] ()
2015-09-27 19:10:32.524 CYLArrayCopyDmo[10681:713670] (
    1,
    2,
    3,
    4
)
</code></pre><p>为了理解这种做法，首先要知道，两种情况：</p>
<ol>
<li>对非集合类对象的 copy 与 mutableCopy 操作；</li>
<li>对集合类对象的 copy 与 mutableCopy 操作。</li>
</ol>
<h5 id="1-对非集合类对象的copy操作："><a href="#1-对非集合类对象的copy操作：" class="headerlink" title="1.对非集合类对象的copy操作："></a>1.对非集合类对象的copy操作：</h5><p>在非集合类对象中：对 immutable 对象进行 copy 操作，是指针复制，mutableCopy 操作时内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。用代码简单表示如下：</p>
<ul>
<li>[immutableObject copy] // 浅复制</li>
<li>[immutableObject mutableCopy] //深复制</li>
<li>[mutableObject copy] //深复制</li>
<li>[mutableObject mutableCopy] //深复制</li>
</ul>
<p>比如以下代码：</p>
<pre><code>NSMutableString *string = [NSMutableString         stringWithString:@&quot;origin&quot;];//copy
NSString *stringCopy = [string copy];
</code></pre><p>查看内存，会发现 string、stringCopy 内存地址都不一样，说明此时都是做内容拷贝、深拷贝。即使你进行如下操作：</p>
<pre><code>[string appendString:@&quot;origion!&quot;]
</code></pre><p>stringCopy 的值也不会因此改变，但是如果不使用 copy，stringCopy 的值就会被改变。 集合类对象以此类推。 所以，用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
<h5 id="2-集合类对象的copy与mutableCopy"><a href="#2-集合类对象的copy与mutableCopy" class="headerlink" title="2.集合类对象的copy与mutableCopy"></a>2.集合类对象的copy与mutableCopy</h5><p>集合类对象是指 NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用 copy 和 mutableCopy 的一个例子：</p>
<pre><code>NSArray *array = @[@[@&quot;a&quot;, @&quot;b&quot;], @[@&quot;c&quot;, @&quot;d&quot;]];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];
</code></pre><p>查看内容，可以看到 copyArray 和 array 的地址是一样的，而 mCopyArray 和 array 的地址是不同的。说明 copy 操作进行了指针拷贝，mutableCopy 进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝 array 这个对象，array 集合内部的元素仍然是指针拷贝。这和上面的非集合 immutable 对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看 mutable 对象拷贝的例子：</p>
<pre><code>NSMutableArray *array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@&quot;a&quot;],@&quot;b&quot;,@&quot;c&quot;,nil];
NSArray *copyArray = [array copy];
NSMutableArray *mCopyArray = [array mutableCopy];        
</code></pre><p>查看内存，如我们所料，copyArray、mCopyArray和 array 的内存地址都不一样，说明 copyArray、mCopyArray 都对 array 进行了内容拷贝。同样，我们可以得出结论：</p>
<p>在集合类对象中，对 immutable 对象进行 copy，是指针复制， mutableCopy 是内容复制；对 mutable 对象进行 copy 和 mutableCopy 都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：    </p>
<pre><code>[immutableObject copy] // 浅复制
[immutableObject mutableCopy] //单层深复制
[mutableObject copy] //单层深复制
[mutableObject mutableCopy] //单层深复制    
</code></pre><p>这个代码结论和非集合类的非常相似。</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/22/SQL必知必会学习(一)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          《SQL必知必会》学习笔记（一）
        
      </div>
    </a>
  
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="东的面试整理" data-title="iOS整理（摘抄与总结面试题为主）" data-url="http://www.chong2vv.com/2016/05/20/东的面试整理/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 七月
    	</div>
      	<div class="footer-right">
      		若水三千,只取一瓢饮
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>